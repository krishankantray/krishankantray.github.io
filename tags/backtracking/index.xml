<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>backtracking on Krishankant</title><link>/tags/backtracking/</link><description>Recent content in backtracking on Krishankant</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 26 Sep 2021 21:15:56 +0000</lastBuildDate><atom:link href="/tags/backtracking/index.xml" rel="self" type="application/rss+xml"/><item><title>Backtracking problems made easy</title><link>/posts/backtracking-problems-made-easy/</link><pubDate>Sun, 26 Sep 2021 21:15:56 +0000</pubDate><guid>/posts/backtracking-problems-made-easy/</guid><description>Backtracking problems seems to be one of the tricky part while studying DSA. But once we figure out a pattern in it, then its even easier than array problems.
A general code structure of a backtracking problem solution looks like :
void Backtrack(int start, vector&amp;lt;int&amp;gt;&amp;amp;arr, int &amp;amp;ans) { //Base case for(int i=start; i&amp;lt;arr.size(); i++) { //include the current element at this position if possible in the ans Backtrack(start+1) // here take care whethere to pass start or start+1 dending on the usecase //backtrack by removing current element } } To avoid duplicates in backtracking, we generally sort the array/list, then keep track of the duplicates by arr[i] == arr[i-1].</description><content>&lt;p>Backtracking problems seems to be one of the tricky part while studying DSA. But once we figure out a pattern in it, then its even easier than array problems.&lt;/p>
&lt;p>A general code structure of a backtracking problem solution looks like :&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Backtrack&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> start, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span>arr, &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>ans)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//Base case
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>start; i&lt;span style="color:#f92672">&amp;lt;&lt;/span>arr.size(); i&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//include the current element at this position if possible in the ans
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Backtrack(start&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#75715e">// here take care whethere to pass start or start+1 dending on the usecase
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//backtrack by removing current element
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>To avoid duplicates in backtracking, we generally sort the array/list, then keep track of the duplicates by &lt;code>arr[i] == arr[i-1]&lt;/code>.&lt;/p>
&lt;p>Here are some good backtracking problems which makes our understanding about the topic more firm :&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number">Letter Combinations of a Phone Number&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/generate-parentheses">Generate Parentheses&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/sudoku-solver">Sudoku Solver&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/combination-sum">Combination Sum&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/combination-sum-ii">Combination Sum II&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/permutations">Permutations&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/permutations-ii">Permutations II&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/n-queens">N-Queens&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/combinations">Combinations&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/subsets">Subsets&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/subsets-ii">Subsets II&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/restore-ip-addresses">Restore IP Addresses&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/palindrome-partitioning">Palindrome Partitioning&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/word-break">Word Break&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/combination-sum-iii">Combination Sum III&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/target-sum">Target Sum&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://leetcode.com/problems/letter-case-permutation">Letter Case Permutation&lt;/a>&lt;/li>
&lt;/ol></content></item></channel></rss>